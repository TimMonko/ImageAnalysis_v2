shinytest::recordTest("~/GitHub/ImageAnalysis_v2/R Notebook/R_Image_Analysis_Notebook.Rmd")
tbl.allfiles <- reactive(tibble()) # Pre-allocate the tibble for use with bind_rows
renderPrint(tbl.allfiles())
?tibble
tbl <- tibble()
tbl
renderPrint(tbl)
# tbl.allfiles <- reactive(tibble()) # Pre-allocate the tibble for use with bind_rows
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- reactive({
tbl.label %>%
group_by(z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = input$genotype)
###ADD conditionals here ###
})
renderTable(tbl.centers())
# tbl.allfiles <- reactive(bind_rows(tbl.allfiles(), tbl.centers())) # bind iterations of the tbl.centers to a master list
}
# tbl.allfiles <- reactive(tibble()) # Pre-allocate the tibble for use with bind_rows
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- reactive({
tbl.label %>%
group_by(z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = input$genotype)
###ADD conditionals here ###
})
renderTable(tbl.centers())
# tbl.allfiles <- reactive(bind_rows(tbl.allfiles(), tbl.centers())) # bind iterations of the tbl.centers to a master list
}
# tbl.allfiles <- reactive(tibble()) # Pre-allocate the tibble for use with bind_rows
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- reactive({
tbl.label %>%
group_by(z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = input$genotype)
###ADD conditionals here ###
})
renderTable(tbl.centers())
# tbl.allfiles <- reactive(bind_rows(tbl.allfiles(), tbl.centers())) # bind iterations of the tbl.centers to a master list
}
# tbl.allfiles <- reactive(tibble()) # Pre-allocate the tibble for use with bind_rows
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- reactive({
tbl.label %>%
group_by(z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = input$genotype)
###ADD conditionals here ###
})
renderTable(tbl.centers())
# tbl.allfiles <- reactive(bind_rows(tbl.allfiles(), tbl.centers())) # bind iterations of the tbl.centers to a master list
}
# tbl.allfiles <- reactive(tibble()) # Pre-allocate the tibble for use with bind_rows
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- reactive({
tbl.label %>%
group_by(z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = input$genotype)
###ADD conditionals here ###
})
renderTable(tbl.centers())
# tbl.allfiles <- reactive(bind_rows(tbl.allfiles(), tbl.centers())) # bind iterations of the tbl.centers to a master list
}
rm(tbl.centers)
# tbl.allfiles <- reactive(tibble()) # Pre-allocate the tibble for use with bind_rows
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- reactive({
tbl.label %>%
group_by(z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = input$genotype)
###ADD conditionals here ###
})
renderTable(tbl.centers())
# tbl.allfiles <- reactive(bind_rows(tbl.allfiles(), tbl.centers())) # bind iterations of the tbl.centers to a master list
}
tbl.centers
renderTable(tbl.centers)
renderTable(tbl.centers())
?renderTable
?group_by
rm(tbl.centers)
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
# tbl.allfiles <- reactive(tibble()) # Pre-allocate the tibble for use with bind_rows
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <-   reactive({
group_by(tbl.label, z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = input$genotype)
})
###ADD conditionals here ###
# tbl.allfiles <- reactive(bind_rows(tbl.allfiles(), tbl.centers())) # bind iterations of the tbl.centers to a master list
}
renderTable(tbl.centers())
renderTable(tbl.centers)
?list
list[1] <- tbl.centers
list[[1]] <-tbl.centers
file.tbl
list[[1]] <- file.tbl
biglist <- list()
biglist
class(biglist)
biglist[[1]] <- file.tbl
biglist
list.tbl.centers <- list()
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- reactive({
group_by(tbl.label, z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = input$genotype)
###ADD conditionals here ###
})
list.tbl.centers[[im]] <- tbl.centers
}
renderTable(head(tbl.centers()))
list.tbl.centers[[1]]
isolate(input$genotype)
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
iso.genotype <- isolate(input$genotype)
twelve <- "twelve"
class(twelve)
list.tbl.centers <- list()
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- reactive({
group_by(tbl.label, z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = str_extract(file.paths[im], input$genotype))
###ADD conditionals here ###
})
list.tbl.centers[[im]] <- tbl.centers
}
renderTable(head(tbl.centers()))
list.tbl.centers
list.tbl.centers <- list()
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- reactive({
group_by(tbl.label, z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = str_extract(file.paths[im], input$genotype))
###ADD conditionals here ###
})
iso.tbl <- isolate(tbl.centers)
}
renderTable(head(tbl.centers()))
renderTable(iso.tbl())
iso.tbl
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- tbl.label %>%
group_by(z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2])
test <- exists('all.centers')
if (test == FALSE) {
all.centers <- tbl.centers
} else {
all.centers <- bind_rows(all.centers, tbl.centers)
}
}
renderTable(head(all.centers))
all.centers
view(all.centers)
library(tidyverse) # Includes ggplot2, tidyr, dplyr, stringr, readr, tibble, purrr, forcats
library(svglite) # For exporting plots as .svg graphics to use as vector format
library(broom) # Tidy's up some statistical outputs
library(magick) # A more general image altering package
library(imager) # For loading of stacks, I think to be used with magick
library(shiny) # Not needed when running as .Rmd, but when working through individual chunks it is necessary to load (the YAML header does it with runtime:shiny during .Rmd)
library(knitr)
wd.path <- getwd()
file.paths <- list.files(path = wd.path, pattern = '\\.tif$')
file.tbl <- as_tibble(file.paths)
renderTable(head(file.tbl))
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- tbl.label %>%
group_by(z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2])
test <- exists('all.centers')
if (test == FALSE) {
all.centers <- tbl.centers
} else {
all.centers <- bind_rows(all.centers, tbl.centers)
}
}
### HERE IS WHERE WE DO THE REACTIVE STUFF YOU SILLY GOON
renderTable(head(all.centers))
head(all.centers)
all.centers
re.all.centers <- all.centers %>%
reactive){
re.all.centers <- all.centers %>%
reactive({
mutate(age = input$age)
})
?mutate_if
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
renderPrint(checkboxGroupInput)
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
renderPrint(checkboxGroupInput())
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
renderPrint(input$extractable)
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
renderPrint(input$extractable)
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
renderPrint(input$extractable)
?%in%
?str_detect
?str_extract
"1" %in% input$genotype
?extract
renderPrint("1" %in% input$extractable)
re.all.centers <- reactive({
all.centers %>%
mutate(genotype = str_extract(file, input$genotype))
})
re.genotype.col <- reactive({
extract(all.centers$file, "Genotype", input$genotype)
})
renderPrint(re.genotype.col())
# re.all.centers <- reactive({
#   all.centers %>%
#     {if ("1" %in% input$extractable) {mutate(genotype = str_extract(as.character(all.centers$file), input$genotype))}}
# })
# re.all.centers <- reactive({
# all.centers %>%
#   {if ("1" %in% input$extractable) mutate(genotype = str_extract(all.centers$file, input$genotype))}
# })
# re.all.centers <- reactive({
#   all.centers %>%
#     if ('1' %in% input$extractable) { mutate(genotype = str_extract(all.centers$file, input$genotype)) }
#       else { mutate(genotype = input$genotype) }
# })
### HERE IS WHERE WE DO THE REACTIVE STUFF YOU SILLY GOON
renderTable(head(re.all.centers()))
?as.string
?is.string
?string
?str
?replace_na
?names
install.packages("DT")
library(DT)
?shiny:renderDataTable
?shiny::renderDataTable
?DT::renderDataTable
?datatable
?renderDataTable
?renderDataTable
?relocate
?inputPanel
?inputPanel
?renderPlot
library(tidyverse) # Includes ggplot2, tidyr, dplyr, stringr, readr, tibble, purrr, forcats
library(svglite) # For exporting plots as .svg graphics to use as vector format
library(extrafont) # README: https://cran.r-project.org/web/packages/extrafont/README.html
#font_import(path = 'C:/Users/TimMonko/AppData/Local/Microsoft/Windows/Fonts') # for custom installed .ttf fonts
library(broom) # Tidy's up some statistical outputs
library(ggh4x)
library(MANOVA.RM)
library(rstatix)
library(ggpubr)
library(shiny) # Not needed when running as .Rmd, but when working through individual chunks it is necessary to load (the YAML header does it with runtime:shiny during .Rmd)
library(shinyjqui) # For drag and drop functions such as orderInput
library(knitr) # Helpful for some functions when not running as .Rmd as with shiny
library(DT) # Use this for rendering datatable as html output widgets (shiny:: and DT:: share renderDataTable)
extrafont::loadfonts(device = "win", quiet = TRUE)
Sys.setenv(R_GSCMD="C:/Program Files/gs/gs9.52/bin/gswin64c.exe") # Set the location for Ghostscript for pdf embedding of fonts, use embed_fonts()
`%notin%` = Negate(`%in%`) # Custom function used to define a group by what is NOT in the group
fonts()
font_import()
