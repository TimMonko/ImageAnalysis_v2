list[[1]] <-tbl.centers
file.tbl
list[[1]] <- file.tbl
biglist <- list()
biglist
class(biglist)
biglist[[1]] <- file.tbl
biglist
list.tbl.centers <- list()
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- reactive({
group_by(tbl.label, z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = input$genotype)
###ADD conditionals here ###
})
list.tbl.centers[[im]] <- tbl.centers
}
renderTable(head(tbl.centers()))
list.tbl.centers[[1]]
isolate(input$genotype)
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
iso.genotype <- isolate(input$genotype)
twelve <- "twelve"
class(twelve)
list.tbl.centers <- list()
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- reactive({
group_by(tbl.label, z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = str_extract(file.paths[im], input$genotype))
###ADD conditionals here ###
})
list.tbl.centers[[im]] <- tbl.centers
}
renderTable(head(tbl.centers()))
list.tbl.centers
list.tbl.centers <- list()
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- reactive({
group_by(tbl.label, z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2]) %>%
mutate(genotype = str_extract(file.paths[im], input$genotype))
###ADD conditionals here ###
})
iso.tbl <- isolate(tbl.centers)
}
renderTable(head(tbl.centers()))
renderTable(iso.tbl())
iso.tbl
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- tbl.label %>%
group_by(z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2])
test <- exists('all.centers')
if (test == FALSE) {
all.centers <- tbl.centers
} else {
all.centers <- bind_rows(all.centers, tbl.centers)
}
}
renderTable(head(all.centers))
all.centers
view(all.centers)
library(tidyverse) # Includes ggplot2, tidyr, dplyr, stringr, readr, tibble, purrr, forcats
library(svglite) # For exporting plots as .svg graphics to use as vector format
library(broom) # Tidy's up some statistical outputs
library(magick) # A more general image altering package
library(imager) # For loading of stacks, I think to be used with magick
library(shiny) # Not needed when running as .Rmd, but when working through individual chunks it is necessary to load (the YAML header does it with runtime:shiny during .Rmd)
library(knitr)
wd.path <- getwd()
file.paths <- list.files(path = wd.path, pattern = '\\.tif$')
file.tbl <- as_tibble(file.paths)
renderTable(head(file.tbl))
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
for (im in 1:length(file.paths)) {
# Import complex files with Magick, and then convert to cimg format for use with the imager analysis tools. Imager `load.image` only supports PNG, JPEG and BMP
# Store as a Cimg as an eager representation of the original file. see: plot(image.cimg)
image <- image_read(file.paths[im])
image.cimg <- magick2cimg(image)
image.dims <- dim(image.cimg)   # dim(image.px) [x/width, y/height, z/depth/slices, color channels]
# Store as a pixset (a binary mask of booleans) -- either use as.pixset, or do a mathematical operation on the image
# Multi-channel images have data stored separately, as in [x,y,z,colour]. see: `here(image.px) %>% head` and also `imsplit(image.px, "z") %>% plot
image.px <- image.cimg > 0.5 # Keep pixels above 50% brightness (magick converts to 0-1 scale) -- this is only important if the image was previously straightened in imagej (and thus is grayscale), but either way converts the cimg to a pixset, which is important for the following math
image.label <- label(image.px, high_connectivity = FALSE)   # Label connected components, high_connectivity = FALSE is 4-connectivity in 2d case, and 6 in 3d case. can also set to true for 8-component connectivity
tbl.label <- as.data.frame(image.label) %>%
as_tibble %>% # Convert labeled pixset to tibble, need to use intermediate as.data.frame for compatability
subset(value > 0) # pixels labeled with value == 0 are the non-white cells in the image
tbl.centers <- tbl.label %>%
group_by(z, value) %>%
summarize(x = mean(x), y = mean(y), .groups = "drop_last") %>% # computes the means of the labeled group (via group_by of value, which represents the unique contiguous label)
add_count(z) %>% # adds a count column, works where `mutate(n = count(z))` does not compute
mutate(file = file.paths[im]) %>%
mutate(width = image.dims[1]) %>%
mutate(height = image.dims[2])
test <- exists('all.centers')
if (test == FALSE) {
all.centers <- tbl.centers
} else {
all.centers <- bind_rows(all.centers, tbl.centers)
}
}
### HERE IS WHERE WE DO THE REACTIVE STUFF YOU SILLY GOON
renderTable(head(all.centers))
head(all.centers)
all.centers
re.all.centers <- all.centers %>%
reactive){
re.all.centers <- all.centers %>%
reactive({
mutate(age = input$age)
})
?mutate_if
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
renderPrint(checkboxGroupInput)
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
renderPrint(checkboxGroupInput())
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
renderPrint(input$extractable)
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
renderPrint(input$extractable)
checkboxGroupInput("extractable", label = "Scrape info with str_extract() for...", choices = list("Genotype" = 1, "Pair" = 2, "Region" = 3, "Age" = 4, "EdU" = 5), selected = c(1,2,3))
textInput("genotype", label = "Genotype", value = 'WT|CKO')
textInput("pair", label = "Pair", value = '(?<=Pr)[:digit:]{1,2}')
textInput("region", label = "Region", value = 'S1|V1')
textInput("age", label = "Age")
textInput("edu", label = "EdU")
renderPrint(input$extractable)
?%in%
?str_detect
?str_extract
"1" %in% input$genotype
?extract
renderPrint("1" %in% input$extractable)
re.all.centers <- reactive({
all.centers %>%
mutate(genotype = str_extract(file, input$genotype))
})
re.genotype.col <- reactive({
extract(all.centers$file, "Genotype", input$genotype)
})
renderPrint(re.genotype.col())
# re.all.centers <- reactive({
#   all.centers %>%
#     {if ("1" %in% input$extractable) {mutate(genotype = str_extract(as.character(all.centers$file), input$genotype))}}
# })
# re.all.centers <- reactive({
# all.centers %>%
#   {if ("1" %in% input$extractable) mutate(genotype = str_extract(all.centers$file, input$genotype))}
# })
# re.all.centers <- reactive({
#   all.centers %>%
#     if ('1' %in% input$extractable) { mutate(genotype = str_extract(all.centers$file, input$genotype)) }
#       else { mutate(genotype = input$genotype) }
# })
### HERE IS WHERE WE DO THE REACTIVE STUFF YOU SILLY GOON
renderTable(head(re.all.centers()))
?as.string
?is.string
?string
?str
?replace_na
?names
install.packages("DT")
library(DT)
?shiny:renderDataTable
?shiny::renderDataTable
?DT::renderDataTable
?datatable
?renderDataTable
?renderDataTable
?relocate
?inputPanel
?inputPanel
?renderPlot
library(tidyverse) # Includes ggplot2, tidyr, dplyr, stringr, readr, tibble, purrr, forcats
library(svglite) # For exporting plots as .svg graphics to use as vector format
library(extrafont) # README: https://cran.r-project.org/web/packages/extrafont/README.html
#font_import(path = 'C:/Users/TimMonko/AppData/Local/Microsoft/Windows/Fonts') # for custom installed .ttf fonts
library(broom) # Tidy's up some statistical outputs
library(ggh4x)
library(MANOVA.RM)
library(rstatix)
library(ggpubr)
library(shiny) # Not needed when running as .Rmd, but when working through individual chunks it is necessary to load (the YAML header does it with runtime:shiny during .Rmd)
library(shinyjqui) # For drag and drop functions such as orderInput
library(knitr) # Helpful for some functions when not running as .Rmd as with shiny
library(DT) # Use this for rendering datatable as html output widgets (shiny:: and DT:: share renderDataTable)
extrafont::loadfonts(device = "win", quiet = TRUE)
Sys.setenv(R_GSCMD="C:/Program Files/gs/gs9.52/bin/gswin64c.exe") # Set the location for Ghostscript for pdf embedding of fonts, use embed_fonts()
`%notin%` = Negate(`%in%`) # Custom function used to define a group by what is NOT in the group
fonts()
font_import()
library(tidyverse) # Includes ggplot2, tidyr, dplyr, stringr, readr, tibble, purrr, forcats
library(svglite) # For exporting plots as .svg graphics to use as vector format
library(extrafont) # README: https://cran.r-project.org/web/packages/extrafont/README.html
#font_import(path = 'C:/Users/TimMonko/AppData/Local/Microsoft/Windows/Fonts') # for custom installed .ttf fonts
library(broom) # Tidy's up some statistical outputs
library(ggh4x)
library(MANOVA.RM)
library(rstatix)
library(ggpubr)
library(shiny) # Not needed when running as .Rmd, but when working through individual chunks it is necessary to load (the YAML header does it with runtime:shiny during .Rmd)
library(shinyjqui) # For drag and drop functions such as orderInput
library(knitr) # Helpful for some functions when not running as .Rmd as with shiny
library(DT) # Use this for rendering datatable as html output widgets (shiny:: and DT:: share renderDataTable)
extrafont::loadfonts(device = "win", quiet = TRUE)
Sys.setenv(R_GSCMD="C:/Program Files/gs/gs9.52/bin/gswin64c.exe") # Set the location for Ghostscript for pdf embedding of fonts, use embed_fonts()
`%notin%` = Negate(`%in%`) # Custom function used to define a group by what is NOT in the group
rm(list=ls())
library(tidyverse) # Includes ggplot2, tidyr, dplyr, stringr, readr, tibble, purrr, forcats
library(svglite) # For exporting plots as .svg graphics to use as vector format
library(extrafont) # README: https://cran.r-project.org/web/packages/extrafont/README.html
#font_import(path = 'C:/Users/TimMonko/AppData/Local/Microsoft/Windows/Fonts') # for custom installed .ttf fonts
library(broom) # Tidy's up some statistical outputs
library(ggh4x)
library(MANOVA.RM)
library(rstatix)
library(ggpubr)
library(shiny) # Not needed when running as .Rmd, but when working through individual chunks it is necessary to load (the YAML header does it with runtime:shiny during .Rmd)
library(shinyjqui) # For drag and drop functions such as orderInput
library(knitr) # Helpful for some functions when not running as .Rmd as with shiny
library(DT) # Use this for rendering datatable as html output widgets (shiny:: and DT:: share renderDataTable)
extrafont::loadfonts(device = "win", quiet = TRUE)
Sys.setenv(R_GSCMD="C:/Program Files/gs/gs9.52/bin/gswin64c.exe") # Set the location for Ghostscript for pdf embedding of fonts, use embed_fonts()
`%notin%` = Negate(`%in%`) # Custom function used to define a group by what is NOT in the group
library(tidyverse) # Includes ggplot2, tidyr, dplyr, stringr, readr, tibble, purrr, forcats
library(svglite) # For exporting plots as .svg graphics to use as vector format
library(extrafont) # README: https://cran.r-project.org/web/packages/extrafont/README.html
#font_import(path = 'C:/Users/TimMonko/AppData/Local/Microsoft/Windows/Fonts') # for custom installed .ttf fonts
library(broom) # Tidy's up some statistical outputs
library(ggh4x)
library(MANOVA.RM)
library(rstatix)
library(ggpubr)
library(shiny) # Not needed when running as .Rmd, but when working through individual chunks it is necessary to load (the YAML header does it with runtime:shiny during .Rmd)
library(shinyjqui) # For drag and drop functions such as orderInput
library(knitr) # Helpful for some functions when not running as .Rmd as with shiny
library(DT) # Use this for rendering datatable as html output widgets (shiny:: and DT:: share renderDataTable)
extrafont::loadfonts(device = "win", quiet = TRUE)
Sys.setenv(R_GSCMD="C:/Program Files/gs/gs9.52/bin/gswin64c.exe") # Set the location for Ghostscript for pdf embedding of fonts, use embed_fonts()
`%notin%` = Negate(`%in%`) # Custom function used to define a group by what is NOT in the group
wd.path <- getwd()
file.paths <- list.files(path = wd.path, pattern = '\\.csv$')
csv_bind <- function(wd.path = getwd(), text.pattern){
bound <- do.call(rbind,
lapply(list.files(path = wd.path, pattern = text.pattern),
function(x) read_csv(x)))
return(bound)
}
all.data <- csv_bind(text.pattern = 'centers')
wellPanel(
orderInput("z.ord", label = "Slice", items = unique(all.data$z)),
orderInput("genotype.ord", label = "Genotype", items = unique(all.data$genotype)),
orderInput("pair.ord", label = "Pair", items = unique(all.data$pair)),
orderInput("region.ord", label = "Region", items = unique(all.data$region)),
orderInput("age.ord", label = "Age", items = unique(all.data$age)),
orderInput("edu.ord", label = "EdU", items = unique(all.data$edu))
)
renderText("This value will rescale the pixel values to represent micrometers, for 10X on our microscope the value is 0.63492 (or 1pixel/1.575micrometers")
numericInput("rescale", label = "rescale px/um", value = 0.63492)
re.all.data <- reactive({
all.data %>%
mutate(z = ordered(z, levels = input$z.ord)) %>%
mutate(genotype = ordered(genotype, levels = input$genotype.ord)) %>%
mutate(pair = ordered(pair, levels = input$pair.ord)) %>%
mutate(region = ordered(region, levels = input$region.ord)) %>%
mutate(age = ordered(age, levels = input$age.ord)) %>%
mutate(edu = ordered(edu, levels = input$edu.ord)) %>%
mutate(x.abs.right = (width-x)*input$rescale) %>%
mutate(x.abs.left = x*input$rescale) %>%
mutate(x.rel.right = x/width)
})
# renderText("All Data")
# renderDT(re.all.data(), filter="top", class = 'nowrap', options = list(pageLength = 5, scrollX=TRUE))
re.file.data <- reactive({
re.all.data() %>%
group_by(file, genotype, z, pair, region) %>%
summarize(n.cells = mean(n)) # mean is not really a required function, and should be changed , but need to have a summarize function
})
#### THIS IS THE SPOT THAT IS NOT RENDERING THE PLOT -->>> WHERE IS THE PLOT?
re.file.data.wide <- reactive({
re.file.data() %>%
pivot_wider(id_cols = c(genotype, pair, region), names_from = z, values_from = n)
})
renderDT(re.file.data.wide())
renderPrint(re.file.data.wide())
# renderDT(re.file.data(), filter="top", class = 'nowrap', options = list(pageLength = 5, scrollX=TRUE))
re.pair.data <- reactive({
re.file.data() %>%
group_by(genotype, z, pair, region) %>%
summarize(n.cells.mean = mean(n.cells), n.sd.cells = sd(n.cells))
})
renderDT(re.pair.data(), filter="top", class = 'nowrap', options = list(pageLength = 5, scrollX=TRUE))
paired.t <- reactive({
re.pair.data() %>%
group_by(z, region) %>%
t_test(n.cells.mean ~ genotype, paired = TRUE) %>%
add_significance() %>%
mutate(p.signif = recode(p.signif,"ns"= "")) %>%
mutate(p = round(p, digits = 3)) %>%
mutate(p = format(p, digits = 3)) %>%
mutate(p = replace(p, p == 0, "<0.001"))
})
renderDT(paired.t(), options = list(pageLength = 5, scrollX=TRUE))
re.file.data <- reactive({
re.all.data() %>%
group_by(file, genotype, z, pair, region) %>%
summarize(n.cells = mean(n)) # mean is not really a required function, and should be changed , but need to have a summarize function
})
#### THIS IS THE SPOT THAT IS NOT RENDERING THE PLOT -->>> WHERE IS THE PLOT?
re.file.data.wide <- reactive({
re.file.data() %>%
pivot_wider(id_cols = c(genotype, pair, region), names_from = z, values_from = n)
})
# Render
renderDT(re.file.data.wide())
renderPrint(re.file.data.wide())
# renderDT(re.file.data(), filter="top", class = 'nowrap', options = list(pageLength = 5, scrollX=TRUE))
re.pair.data <- reactive({
re.file.data() %>%
group_by(genotype, z, pair, region) %>%
summarize(n.cells.mean = mean(n.cells), n.sd.cells = sd(n.cells))
})
renderDT(re.pair.data(), filter="top", class = 'nowrap', options = list(pageLength = 5, scrollX=TRUE))
paired.t <- reactive({
re.pair.data() %>%
group_by(z, region) %>%
t_test(n.cells.mean ~ genotype, paired = TRUE) %>%
add_significance() %>%
mutate(p.signif = recode(p.signif,"ns"= "")) %>%
mutate(p = round(p, digits = 3)) %>%
mutate(p = format(p, digits = 3)) %>%
mutate(p = replace(p, p == 0, "<0.001"))
})
renderDT(paired.t(), options = list(pageLength = 5, scrollX=TRUE))
# get and load ".csv" files in the working directory of the current .Rmd file
wd.path <- getwd()
file.paths <- list.files(path = wd.path, pattern = '\\.csv$')
# function binds .csv's loaded into file.paths. They are bound according to sharing a certain pattern of text (such as 'centers'). This maintains legacy saving of data variables where there was 'all_centers' and 'pair_mean' outputs, etc., from the analysis file
csv_bind <- function(wd.path = getwd(), text.pattern){
bound <- do.call(rbind,
lapply(list.files(path = wd.path, pattern = text.pattern),
function(x) read_csv(x)))
return(bound)
}
all.data <- csv_bind(text.pattern = 'centers')
wellPanel(
orderInput("z.ord", label = "Slice", items = unique(all.data$z)),
orderInput("genotype.ord", label = "Genotype", items = unique(all.data$genotype)),
orderInput("pair.ord", label = "Pair", items = unique(all.data$pair)),
orderInput("region.ord", label = "Region", items = unique(all.data$region)),
orderInput("age.ord", label = "Age", items = unique(all.data$age)),
orderInput("edu.ord", label = "EdU", items = unique(all.data$edu))
)
renderText("This value will rescale the pixel values to represent micrometers, for 10X on our microscope the value is 0.63492 (or 1pixel/1.575micrometers")
numericInput("rescale", label = "rescale px/um", value = 0.63492)
re.all.data <- reactive({
all.data %>%
mutate(z = ordered(z, levels = input$z.ord)) %>%
mutate(genotype = ordered(genotype, levels = input$genotype.ord)) %>%
mutate(pair = ordered(pair, levels = input$pair.ord)) %>%
mutate(region = ordered(region, levels = input$region.ord)) %>%
mutate(age = ordered(age, levels = input$age.ord)) %>%
mutate(edu = ordered(edu, levels = input$edu.ord)) %>%
mutate(x.abs.right = (width-x)*input$rescale) %>%
mutate(x.abs.left = x*input$rescale) %>%
mutate(x.rel.right = x/width)
})
# renderText("All Data")
# renderDT(re.all.data(), filter="top", class = 'nowrap', options = list(pageLength = 5, scrollX=TRUE))
?read_csv
re.all.data <- reactive({
all.data %>%
mutate(z = ordered(z, levels = input$z.ord)) %>%
mutate(genotype = ordered(genotype, levels = input$genotype.ord)) %>%
mutate(pair = ordered(pair, levels = input$pair.ord)) %>%
mutate(region = ordered(region, levels = input$region.ord)) %>%
mutate(age = ordered(age, levels = input$age.ord)) %>%
mutate(edu = ordered(edu, levels = input$edu.ord)) %>%
mutate(x.abs.right = (width-x)*input$rescale) %>%
mutate(x.abs.left = x*input$rescale) %>%
mutate(x.rel.right = x/width)
})
# renderText("All Data")
# renderDT(re.all.data(), filter="top", class = 'nowrap', options = list(pageLength = 5, scrollX=TRUE))
?checkboxGroupInput
?selectizeInput
?checkboxGroupInput
all.data
rm.groups <- paste0(unique(all.data$pair, all.data$region))
unique(all.data$pair)
paste0(unique(all.data$pair), unique(all.data$region))
rm.groups <- paste(unique(all.data$region), unique(all.data$pair))
rm.groups
rm.groups
rm.groups <- paste(unique(all.data$region), "Pair", unique(all.data$pair))
rm.groups
rm.groups <- paste0("Region:", unique(all.data$region), " Pr:", unique(all.data$pair))
rm.groups
rm.region <- str_extract(rm.groups, value = "(?<=Pr:)[:digit:]{1,2}")
rm.region <- str_extract(rm.groups, "(?<=Pr:)[:digit:]{1,2}")
rm.region
rm.groups <- paste0(unique(all.data$region), unique(all.data$pair))
rm.groups
rm.groups <- paste0(unique(all.data$region), "-", unique(all.data$pair))
rm.groups
?theme_classic
library(unicycles)
?theme
?geom_jitter
ignette("ggplot2-specs")
vignette("ggplot2-specs")
?ggsave
?renderPlot
?renderPlot
?ggsave
